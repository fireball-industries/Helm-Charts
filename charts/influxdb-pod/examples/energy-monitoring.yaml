# Energy Monitoring InfluxDB Deployment
# For tracking energy consumption, demand, and power quality
# Compliance with ISO 50001, energy reporting regulations

deploymentMode: single
resourcePreset: small

influxdb:
  organization: "facilities-energy"
  bucket: "energy"
  retention: "2555d"  # 7 years (regulatory requirement)
  logLevel: info

# Energy-specific buckets
industrialBuckets:
  enabled: true
  buckets:
    - name: "energy"
      retention: "2555d"  # 7 years
      description: "Main energy meters and consumption"
    - name: "power_quality"
      retention: "365d"
      description: "Voltage, current, harmonics, power factor"
    - name: "demand"
      retention: "2555d"
      description: "Peak demand tracking for billing"
    - name: "renewable"
      retention: "2555d"
      description: "Solar/wind generation"
    - name: "carbon"
      retention: "2555d"
      description: "Carbon emissions calculations"

# Data retention (long-term for compliance)
dataRetention:
  enabled: true
  hot:
    duration: "30d"  # 30 days full precision
  warm:
    duration: "365d"  # 15-minute intervals for 1 year
    interval: "15m"
  cold:
    duration: "2555d"  # 1-hour intervals for 7 years
    interval: "1h"

# Persistent storage
persistence:
  enabled: true
  storageClass: "standard"
  size: "100Gi"
  retainOnDelete: true

# Automated backups (compliance)
backup:
  enabled: true
  schedule: "0 4 * * *"  # 4 AM daily
  retention: 90  # Keep 90 days
  destination:
    type: pvc
    pvc:
      size: "50Gi"

# Telegraf for energy meter data collection
telegraf:
  enabled: true
  config: |
    [agent]
      interval = "15s"  # 15-second sampling (ISO 50001 recommended)
      round_interval = true
      metric_batch_size = 1000
      metric_buffer_limit = 10000
      flush_interval = "30s"
    
    [[outputs.influxdb_v2]]
      urls = ["http://localhost:8086"]
      token = "$INFLUX_TOKEN"
      organization = "$INFLUX_ORG"
      bucket = "energy"
    
    # Modbus for energy meters (common protocol)
    [[inputs.modbus]]
      name = "main-meter"
      slave_id = 1
      timeout = "1s"
      controller = "tcp://10.0.50.10:502"
      
      holding_registers = [
        {name = "voltage_l1", byte_order = "AB", data_type = "FLOAT32", scale=1.0, address = [0,1]},
        {name = "voltage_l2", byte_order = "AB", data_type = "FLOAT32", scale=1.0, address = [2,3]},
        {name = "voltage_l3", byte_order = "AB", data_type = "FLOAT32", scale=1.0, address = [4,5]},
        {name = "current_l1", byte_order = "AB", data_type = "FLOAT32", scale=1.0, address = [6,7]},
        {name = "current_l2", byte_order = "AB", data_type = "FLOAT32", scale=1.0, address = [8,9]},
        {name = "current_l3", byte_order = "AB", data_type = "FLOAT32", scale=1.0, address = [10,11]},
        {name = "active_power", byte_order = "AB", data_type = "FLOAT32", scale=1.0, address = [12,13]},
        {name = "reactive_power", byte_order = "AB", data_type = "FLOAT32", scale=1.0, address = [14,15]},
        {name = "power_factor", byte_order = "AB", data_type = "FLOAT32", scale=0.01, address = [16,17]},
        {name = "frequency", byte_order = "AB", data_type = "FLOAT32", scale=0.01, address = [18,19]},
        {name = "total_kwh", byte_order = "AB", data_type = "FLOAT32", scale=1.0, address = [20,21]},
      ]
    
    [[inputs.modbus]]
      name = "line1-meter"
      slave_id = 2
      timeout = "1s"
      controller = "tcp://10.0.50.11:502"
      
      holding_registers = [
        {name = "active_power", byte_order = "AB", data_type = "FLOAT32", scale=1.0, address = [12,13]},
        {name = "total_kwh", byte_order = "AB", data_type = "FLOAT32", scale=1.0, address = [20,21]},
      ]
    
    [[inputs.modbus]]
      name = "hvac-meter"
      slave_id = 3
      timeout = "1s"
      controller = "tcp://10.0.50.12:502"
      
      holding_registers = [
        {name = "active_power", byte_order = "AB", data_type = "FLOAT32", scale=1.0, address = [12,13]},
        {name = "total_kwh", byte_order = "AB", data_type = "FLOAT32", scale=1.0, address = [20,21]},
      ]
    
    # SNMP for UPS systems
    [[inputs.snmp]]
      agents = ["10.0.50.20:161", "10.0.50.21:161"]
      version = 2
      community = "public"
      name = "ups"
      
      [[inputs.snmp.field]]
        name = "battery_status"
        oid = ".1.3.6.1.4.1.318.1.1.1.2.1.1.0"
      
      [[inputs.snmp.field]]
        name = "battery_capacity"
        oid = ".1.3.6.1.4.1.318.1.1.1.2.2.1.0"
      
      [[inputs.snmp.field]]
        name = "output_load"
        oid = ".1.3.6.1.4.1.318.1.1.1.4.2.3.0"
    
    # HTTP input for solar inverter
    [[inputs.http]]
      urls = ["http://solar-inverter.local/api/energy"]
      method = "GET"
      data_format = "json"
      name_override = "solar"
      tagexclude = ["url"]
    
    # Processor: Calculate carbon emissions
    [[processors.starlark]]
      source = '''
def apply(metric):
    # Carbon intensity: 0.92 lbsCO2/kWh (US average)
    if metric.name == "energy" and "total_kwh" in metric.fields:
        kwh = metric.fields["total_kwh"]
        metric.fields["carbon_lbs"] = kwh * 0.92
        metric.fields["carbon_kg"] = kwh * 0.417
    return metric
'''
  
  resources:
    limits:
      cpu: "300m"
      memory: "384Mi"
    requests:
      cpu: "150m"
      memory: "192Mi"

# Ingress for energy dashboard
ingress:
  enabled: true
  className: "nginx"
  annotations:
    cert-manager.io/cluster-issuer: "letsencrypt-prod"
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
  hosts:
    - host: energy.factory.local
      paths:
        - path: /
          pathType: Prefix
  tls:
    - secretName: energy-influxdb-tls
      hosts:
        - energy.factory.local

# Monitoring
monitoring:
  prometheus:
    enabled: true
  serviceMonitor:
    enabled: true

# Grafana for energy dashboards
grafana:
  datasource:
    enabled: true
    namespace: "monitoring"

# Security
security:
  runAsNonRoot: true
  podSecurityStandard: restricted

# Resources
resources:
  limits:
    cpu: "1"
    memory: "1Gi"
  requests:
    cpu: "500m"
    memory: "1Gi"

# Health checks
livenessProbe:
  httpGet:
    path: /health
    port: 8086
  initialDelaySeconds: 30
  periodSeconds: 10

readinessProbe:
  httpGet:
    path: /health
    port: 8086
  initialDelaySeconds: 5
  periodSeconds: 10
